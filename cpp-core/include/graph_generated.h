// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GRAPH_MENTIS_H_
#define FLATBUFFERS_GENERATED_GRAPH_MENTIS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace Mentis {

struct Node;
struct NodeBuilder;

struct Graph;
struct GraphBuilder;

enum DType : int8_t {
  DType_FLOAT32 = 0,
  DType_INT32 = 1,
  DType_MIN = DType_FLOAT32,
  DType_MAX = DType_INT32
};

inline const DType (&EnumValuesDType())[2] {
  static const DType values[] = {
    DType_FLOAT32,
    DType_INT32
  };
  return values;
}

inline const char * const *EnumNamesDType() {
  static const char * const names[3] = {
    "FLOAT32",
    "INT32",
    nullptr
  };
  return names;
}

inline const char *EnumNameDType(DType e) {
  if (::flatbuffers::IsOutRange(e, DType_FLOAT32, DType_INT32)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDType()[index];
}

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4,
    VT_SHAPE = 6,
    VT_DTYPE = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS = 12
  };
  const ::flatbuffers::String *op() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OP);
  }
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  Mentis::DType dtype() const {
    return static_cast<Mentis::DType>(GetField<int8_t>(VT_DTYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OP) &&
           verifier.VerifyString(op()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfStrings(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfStrings(outputs()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op(::flatbuffers::Offset<::flatbuffers::String> op) {
    fbb_.AddOffset(Node::VT_OP, op);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Node::VT_SHAPE, shape);
  }
  void add_dtype(Mentis::DType dtype) {
    fbb_.AddElement<int8_t>(Node::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs) {
    fbb_.AddOffset(Node::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs) {
    fbb_.AddOffset(Node::VT_OUTPUTS, outputs);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> op = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    Mentis::DType dtype = Mentis::DType_FLOAT32,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputs = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_shape(shape);
  builder_.add_op(op);
  builder_.add_dtype(dtype);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *op = nullptr,
    const std::vector<int32_t> *shape = nullptr,
    Mentis::DType dtype = Mentis::DType_FLOAT32,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputs = nullptr) {
  auto op__ = op ? _fbb.CreateString(op) : 0;
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputs) : 0;
  return Mentis::CreateNode(
      _fbb,
      op__,
      shape__,
      dtype,
      inputs__,
      outputs__);
}

struct Graph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NODES = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Mentis::Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Mentis::Node>> *>(VT_NODES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Graph::VT_ID, id);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Mentis::Node>>> nodes) {
    fbb_.AddOffset(Graph::VT_NODES, nodes);
  }
  explicit GraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Graph> CreateGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Mentis::Node>>> nodes = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Graph> CreateGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<::flatbuffers::Offset<Mentis::Node>> *nodes = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<Mentis::Node>>(*nodes) : 0;
  return Mentis::CreateGraph(
      _fbb,
      id__,
      nodes__);
}

inline const Mentis::Graph *GetGraph(const void *buf) {
  return ::flatbuffers::GetRoot<Mentis::Graph>(buf);
}

inline const Mentis::Graph *GetSizePrefixedGraph(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Mentis::Graph>(buf);
}

inline bool VerifyGraphBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Mentis::Graph>(nullptr);
}

inline bool VerifySizePrefixedGraphBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Mentis::Graph>(nullptr);
}

inline void FinishGraphBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Mentis::Graph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGraphBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Mentis::Graph> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Mentis

#endif  // FLATBUFFERS_GENERATED_GRAPH_MENTIS_H_
